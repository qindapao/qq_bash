
现在还有一个最大的问题。是我当前的脚本使用了bash5.3的高性能新语法，但是在低版本
    的bash上是不行的。所以还要写一个类似于编译宏的东西。用awk处理脚本标记，根据
    bash版本选择不同的代码段，生成生产环境真实脚本。类似于部署库前先构建一下。

    可以通过版本判断某些特性，或者通过测试代码判断时候支持某个特性！
    或者同时使用两种方法判断，有些通过版本判断有些通过测试代码判断
    #@if HAS_ARRAY_K
    #@if HAS_LOCAL_N
    #@if HAS_VFLAG
    #@if BASH_GE_52
    #@if BASH_GE_50

    bash -c 'declare -A a; a[x]=1; echo ${a@K}' >/dev/null 2>&1

    代码片段替代
    #@replace FUNCNAME
    ${FUNCNAME[0]}
    #@with
    ${0##*/}
    #@end


实现数组的高效切片操作

重构方案，阶段二:
    提供和 bjson.sh 模块的互通，可以把当前的trie树直接序列化成一个JSON对象，或者把JSON对象反序列化
        成我们的trie树。
    bjson.sh 的类型判断逻辑也使用($X开头或者结尾)？和 trie.sh 统一。并且字符串的开头默认不写 $S,改掉以前的 s: i: 这种语义！
    bjson.sh 也需要实现一个walk函数即可，然后和当前的相关转换就行。


重构方案，阶段三(可选):
    - full_key 可以考虑移除，这样可以减少节点数量，可以通过动态路径拼接获得 full_key，不需要用 key 来存储，不过现阶段可以暂时保留。
        移除后索引稍微麻烦点，先阶段保留。
    - 如果节点数量膨胀得太厉害。可以考虑把 child 的 id 一起压缩到 children 里面。
        当前这样的优势是结构清晰，索引速度快，排序 children 也比较方便，但是有点浪费空间。
        如果取消掉 child ，那么 children 的拆分就会比较复杂了，可能会浪费时间。

array
    普通数组的交集、合集、差集的方法，关联数组如果当成集合使用也可以做

test.sh
    测试失败的脚本名字和用例名字，还有子用例名字都应该要收集起来在最后的地方呈现给用户。
    方便回查问题。

