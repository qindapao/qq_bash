
现在还有一个最大的问题。是我当前的脚本使用了bash5.3的高性能新语法，但是在低版本
    的bash上是不行的。所以还要写一个类似于编译宏的东西。用awk处理脚本标记，根据
    bash版本选择不同的代码段，生成生产环境真实脚本。类似于部署库前先构建一下。

    可以通过版本判断某些特性，或者通过测试代码判断时候支持某个特性！
    或者同时使用两种方法判断，有些通过版本判断有些通过测试代码判断
    #@if HAS_ARRAY_K
    #@if HAS_LOCAL_N
    #@if HAS_VFLAG
    #@if BASH_GE_52
    #@if BASH_GE_50

    bash -c 'declare -A a; a[x]=1; echo ${a@K}' >/dev/null 2>&1

    代码片段替代
    #@replace FUNCNAME
    ${FUNCNAME[0]}
    #@with
    ${0##*/}
    #@end


实现数组的高效切片操作

重构方案，阶段三(可选):
    - full_key 可以考虑移除，可以通过动态路径拼接获得 full_key，不需要用 key 来存储，不过现阶段可以暂时保留。
        移除后索引稍微麻烦点，先阶段保留。
        移除后还需要增加一个类型字段占位，没有减少键数量，所以意义不是很大。
    - 如果节点数量膨胀得太厉害。可以考虑把 child 的 id 一起压缩到 children_ids 里面。
        原来的 children 还是保存 child token 的列表，但是 children_ids 里面是一个序列化后的关联数组
        保存的是每个 child token 对应的ID
        这样不管有多少个孩子，就只需要两个键: children 和 children_ids, 不需要一堆 child 键，只是序列化和反序列化增加
        了运行时间，但是可以显著减少节点数量

        unset -v children_ids_map children_ids children
        X=$'\034'
        token1="{key1}"
        token2="{key2}"
        children="{$token1}$X{$token2}$X"

        declare -A children_ids_map=([{$token1}]=234 [{$token2}]=456)
        children_ids=${children_ids_map[*]@K}


        declare -A "children_ids_map=($children_ids)"

        declare -p children_ids_map
        declare -p children_ids
        declare -p children

array
    普通数组的交集、合集、差集的方法，关联数组如果当成集合使用也可以做

test.sh
    测试失败的脚本名字和用例名字，还有子用例名字都应该要收集起来在最后的地方呈现给用户。
    方便回查问题。

trie.sh
    性能优化
        *. 从 children 数组中找 token 的数字索引不需要先把它转换成数组然后再找，可以考虑使用类似下面
            这种方法，效率非常高
            https://github.com/akinomyoga/ble.sh/blob/master/src/util.sh
            ## @fn ble/string#last-index-of text needle [n]
            ##   @param[in] text
            ##   @param[in] needle
            ##   @param[in] n
            ##     この引数を指定したとき n 番目の一致を検索します。
            ##   @var[out] ret
            function ble/string#last-index-of {
              local haystack=$1 needle=$2 count=${3:-1}
              ble/string#repeat '"$needle"*' "$count"; local pattern=$ret
              builtin eval "local transformed=\${haystack%$pattern}"
              if [[ $transformed == "$haystack" ]]; then
                ret=-1
              else
                ret=${#transformed}
              fi
              ((ret>=0))
            }
            当前由于token是Q字符串，所以如果夹带了索引，要一起寻找匹配Q字符串+ID。

    对象初始化性能优化
        my_class.sh 如果创建 150 个对象，需要 15秒。1秒只能创建 10 个对象, bless的速度太慢了。
    
    函数限制
        trie_to_json
        trie_to_json_slow
        这两个函数最大的问题是，我们直接把要写入的 JSON 的值通过 $value 参数的形式
        传递给 gobolt 工具。那么如果这个值很大，或者很多(trie_to_json)传递多组值，
        可能超过命令行的最大限制(ARG_MAX)
        虽然 ARG_MAX 限制的是“总长度”，但单个参数也不能超过 128KB 左右
        （glibc 的内部实现限制）。
        解决方法是把要写入的东西放文件中，对于单个写入的场景，有现成的命令
        复合写入的场景，我们要更新gobolt工具，针对文件我们解析格式，然后写入多组值
        内容就从文件中拿了，就不通过命令行参数传进去。
        环境变量也不能太大，就是环境变量占用的空间也不能超过限制，通常是2M。
        小 JSON 的情况下是完全够用的。
        
