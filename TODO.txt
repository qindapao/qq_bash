
重构目标：通过 trie 在 bash 中实现真正的易用的 JSON 树。

重构方案，阶段一:
    - 验证树中键值存在控制字符的情况
    - 增加叶子节点类型隐形标记，不需要显示指定，通过值是否以 $S 结尾(或者可能开头更好？)来判断。
        数字(num) null(null) true(true) false(false)
        array([]) obj({})

        null$S     - 表示写入了 null，而不是字符串 null
        18.903$S   - 表示写入了数字 18.903，而不是字符串 18.903
        true$S     - 表示写入了 true，而不是字符串 true
        false$S    - 表示写入了 false，而不是字符串 false
        {}$S       - 表示写入了空对象，而不是字符串 {}
        []$S       - 表示写入了空数组，而不是字符串 []
        不以$S结尾 - 表示写入的是普通字符串，大部分情况都是它。

    - 叶子节点判断逻辑需要重写，因为会出现空 array 和 空 obj
    - 删除的逻辑需要修改，现在不存在往上递归删除剪枝条的情况
    - 插入的判断需要修改，往上查找路径的时候可以出现叶子的 obj 或者 array 了。
    - 写入键的时候可能需要重新设计下(所以key对应的键需要用{}和[]包裹，这打印出来也美观)：
        - {}包裹的键认为是操作字典
        - []包裹的键认为是操作数组
        举例:
            tr_t["{key1}$S[435]$S{key2}$S"]
            这里表示索引的是字典键 key1 下面的 435 这个ID地址 的这个数组元素(非索引)，
            这个元素本身是一个字典，这个字典的 key2 键。
        没有歧义也没有啰嗦，$S 分隔符保证键拆解的绝对正确性。
    - iter 函数针对数组的情况可以只返回值了。(如果是叶子)，
        非叶子还是返回ID和index比较好。
    - 数组键的设计就更加简单
        lev1-1(2)                        
            lev2-1(3)                    
                lev3-1(4) => value1      
                lev2-2(5)                    
                    0(7) => 17.65$S
                    11(6) => null$S
            lev2-3(8)                    
                lev3-1(9)                
                    lev4-1(10) => true$S
                    lev4-2(11) => false$S
                lev3-2(12)
                    [0](13) => 17.65
                    [1](14) => array_value1
                    [2](15) => null$S
                    [3](16) => array_value2
                    [4](17) => []$S
                    [5](18) => {}$S

        对于上面的数，所有的叶子节点是:
            {lev1-1}$S{lev2-1}$S{lev3-1}$S = value1
            {lev1-1}$S{lev2-1}$S{lev2-2}$S{0}$S = 17.65$S
            {lev1-1}$S{lev2-1}$S{lev2-2}$S{11}$S = null$S
            ... ...

        如上面所示，数组的真实索引其实是顺序，所以我们只需要对字典键进行字典序插入排序。
        针对数组的ID排列是不需要排序的。对数组来说这只是一个地址而已。真实的顺序就是它们的
        插入顺序。并且往数组中直接插入ID前需要验证合法，不然就会破坏数据，这个要跟用户说清楚。
        提供接口动态获取数据下一个元素插入地址。(非常重要！)而不是暴力插入。只要出现一个数组键
        就需要得到一个ID。其实安全的方式是通过 push/unshift/insert/pop/shift 方法来访问数组。
        数组中的空洞，通过设置 null$S 值来，和JSON完全一样。

        数组为什么不把索引作为键？而是使用 ID 地址？
            这是为了保证在 trie 树中进行 shift 或者 unshift 操作的 O(N)，不然就必须要
            遍历子树，更新所有的叶子节点的 key value 的值，会非常麻烦。
            现在这个方案，由于树中的每个数组节点的ID是唯一的，数组头部或者中间插入一个元素，只需要新申请一个
            ID即可，然后插入到 children 列表对应的位置就行了，不至于要重新修改数组的所有的后面的 token 内容。
            设置这样，数组 节点 都不需要 child 键
            12.children="123{$S}4{$S}67${S}"
            因为 children 中的每个节点的 token 就是它的ID。这和字典的情况不同，字典的 token 是键，不是ID。
            9.children="key1${S}key2${S}key3${S}"
            9.child.key1 = 34
            9.child.key2 = 45
            9.child.key3 = 65
            
            造成这个差异的根本原因是数组的索引本质上是没有意义的，它只是一个顺序标记。
            但是字典不一样，它是有意义的可hash的字符串。
        叶子节点插入的时候[]中的语义要单独拎出来，方便用户使用。
            这里[]中就指定了插入的位置，0表示数组头，-1表示数组尾，其他的正数和负数也是对应的函数。
            这里[]中就不再是ID了。
            或者是提供两个 API ，一个API中的语义是 index，一个API中的语义是 ID。感觉这样更好些？
            用户可以根据实际情况选择正确的API来插入叶子。
            比如 trie_array_insert t "{key1}$S[-1]$S{key2}$S[4]$S"
            如果是按照 index 插入数组，那么中间的空洞必须使用 null$S 填充，这也很容易办到。
        数组的 pop/shift/unshift/push/array_insert 要能处理叶子和子树。
        push/unshift/array_insert 不用担心，因为是写入操作，都传引用变量名就行了，API内部会处理。
        pop/shift 可以考虑想把序列化的结果保存到 REPLY 变量中，然后函数提供不同的返回值
            0 子树
            1 叶子(具体什么叶子，用户直接通过$S判断)
            2 错误
            

重构方案，阶段二:
    提供和 bjson.sh 模块的互通，可以把当前的trie树直接序列化成一个JSON对象，或者把JSON对象反序列化
        成我们的trie树。
    bjson.sh 的类型判断逻辑也使用($S开头或者结尾)？和 trie.sh 统一。并且字符串的开头默认不写 $S,改掉以前的 s: i: 这种语义！
    提供方便的函数可以直接挂接一个普通数组或者一个关联数组
    提供方便的函数把某个扁平化的树成可以直接取成一个普通数组或者关联数组


重构方案，阶段三(可选):
    - 节点存在标记 T[id]=1 可以考虑移除
    - full_key 可以考虑移除，这样可以减少节点数量，可以通过动态路径拼接获得 full_key，不需要用 key 来存储，不过现阶段可以暂时保留。
    - 如果节点数量膨胀得太厉害。可以考虑把 child 的 id 一起压缩到 children 里面。
        并且取消节点ID存在标记。ID的作用是可以快速判断节点是否存在，可能有用。
        当前这样的优势是结构清晰，索引速度快，排序 children 也比较方便，但是有点浪费空间。
        如果取消掉 child ，那么 children 的拆分就会比较复杂了，可能会浪费时间。

trie_id_rebuild
    更加复杂的树的验证

array
    array_qsort
    array_sorted_insert
        验证 unicode 字符排序情况
        asort 内置在 msys2 无法编译
        验证这两个函数的极端用例,特别是array_qsort是否有卡死风险
    普通数组的交集、合集、差集的方法，关联数组如果当成集合使用也可以做

eval
    ${|function;} 函数可以直接返回一段代码，可用于快速执行当前作用域的代码。

test.sh
    测试失败的脚本名字和用例名字，还有子用例名字都应该要收集起来在最后的地方呈现给用户。
    方便回查问题。

代码整改
    代码中还存在一些中文注释，需要全部替换成英文。
    当前所有的函数都是通过 fullkey 来索引树的，如果用户直接拿到了 节点的 ID 呢？
        这种情况下是否直接使用节点 ID 来查找更加快速啊？所有的API都需要支持使用节点 ID
        来直接索引吗？

疯狂的想法(因为没有多大的价值，所以很大的概率永远都不会被实现)
    bash怎么才能模拟面向对象的编程风格啊？不同的基类和子类怎么分发函数？
    我觉得可以像C语言那样在结构体里面挂接函数钩子(我们可以把函数名挂接在字典树中)。
    定义同样的键，指向不同的函数。如果值是空，就找父函数？或者维护一个继承树？
    或者为了简化操作就强制绑定特定的函数？
    
    如何实现 Supper::(Bash的函数名可以用::符号) 呢？函数可以拿到对象变量名。进去后
    可以查看调用树。相应的 Supper 函数甚至可以用 eval 动态生成。


