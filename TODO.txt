
重构阶段一（无数组）：
    - 移除 key 键（full_key 不再存储，遍历时动态拼接路径）
    - 移除节点存在标记（如 T[ID]=1）
    - 用“是否有 value”判断叶子节点
    - 保留 children / child.<token> 结构不变

重构阶段二（数组）：
    - 增加节点数组标记（如 T[ID.array]=1）
    - trie_insert：
        - 字典语义，不关心数组，允许任何 key
        - 若命中数组层且 key 非数字 → 报错，不要插入任何数据

    - trie_graft
        - 字典语义，不关心数组，允许任何 key
        - 但如果路径命中数组层：
            - key 必须是数字
            - 否则报错，且必须在删除旧节点前检查（避免“先删后插失败”导致数据丢失）

    - trie_array_*：数组语义，只在这里处理数组规则：
        - 第一次在某节点调用数组 API(ID.array还未生成的时候)：
            - 若该层已有非数字子键(或者用数组insert函数插入非数字索引) → 报错
            - 若全部为数字或者不存在 -> 设置数组标记（ID.array=1）

        - 若已是数组层(ID.array已经生成)：
            - 只需要检查 数组 insert 函数传入的索引是否是数字，非数字报错
            - push/pop/shift/unshift 完全不用检查
            - 不需要检查原始的children是否全是数字(ID.array标记就保证了历史状态合法)

    - trie_array_push/pop/shift/unshift：
        - 支持写扁平数组根
        - 支持挂接子树，删除操作前一定确保 路径合法(若路径命中数组层且 key 非数字 -> 报错)

    - O(n)/O(1) 细节后续再定（shift/unshift O(n)，push/pop O(1)）

trie
    实现trie的数组
        但是当前的模型下，由于叶子节点保存了 full_key ,所以如果要做数组的插入，
        所有的子树的 full_key 全部要更新代价巨大。

        其实可以 不要 保存 full_key ,需要 full_key 的时候都靠动态拼接实现，然后通过是否
        有 key - value 来判断是否是叶子节点
        等重构 移除 key 键结束后就可以进行数组的开发

        好了，如何识别某层是数组呢？

        trie_insert：始终是“字典语义”，不关心数组，允许任何 key 形态。
        trie_array_*：数组语义，只在这套 API 里关心“是否为数组层级”的判断（数组标记），以及保证 key 必须是数字。

        也就是说：
        用户想当字典用 → 永远用 trie_insert，不管 key 长啥样。
        用户想当数组用 → 在某个前缀上调用 trie_array_push/shift/...，从这一刻起，这个前缀下面“变成了一个数组视角”。

        trie_array_pop/shift/push/unshift 需要设计两种函数，写叶子和挂接子树。

        所以insert的时候也要检查每个层级。如果某个层级已经存在 array_offset 标记，
            但是还在这个层插入非数字键，显然是必须要报错的！否则想怎么插入都可以。

    验证树中存在控制字符的情况
    提供方便的函数可以直接挂接一个普通数组或者一个关联数组
    提供方便的函数把某个扁平化的树成可以直接取成一个普通数组或者关联数组
    trie_iter 返回的数据太不灵活了，可以考虑增加一个bitmap的参数，每个bit位代表不同
        的属性，用户可以指定返回的数据是哪些。
        函数开发完成，待测试
    trie_id_rebuild
        更加复杂的树的验证
    如果节点数量膨胀得太厉害。可以考虑把 child 的 id 一起压缩到 children 里面。并且取消
    节点ID存在标记。ID的作用是可以快速判断节点是否存在，可能有用。
    当前这样的优势是结构清晰，索引速度快，排序 children 也比较方便，但是有点浪费空间。
    如果取消掉 child ，那么 children 的拆分就会比较复杂了，可能会浪费时间。

array
    array_qsort
    array_sorted_insert
        验证 unicode 字符排序情况
        asort 内置在 msys2 无法编译
        验证这两个函数的极端用例,特别是array_qsort是否有卡死风险
    普通数组的交集、合集、差集的方法，关联数组如果当成集合使用也可以做

eval
    ${|function;} 函数可以直接返回一段代码，可用于快速执行当前作用域的代码。

test.sh
    测试失败的脚本名字和用例名字，还有子用例名字都应该要收集起来在最后的地方呈现给用户。
    方便回查问题。

代码整改
    代码中还存在一些中文注释，需要全部替换成英文。
    当前所有的函数都是通过 fullkey 来索引树的，如果用户直接拿到了 节点的 ID 呢？
        这种情况下是否直接使用节点 ID 来查找更加快速啊？所有的API都需要支持使用节点 ID
        来直接索引吗？

疯狂的想法(因为没有多大的价值，所以很大的概率永远都不会被实现)
    bash怎么才能模拟面向对象的编程风格啊？不同的基类和子类怎么分发函数？
    我觉得可以像C语言那样在结构体里面挂接函数钩子(我们可以把函数名挂接在字典树中)。
    定义同样的键，指向不同的函数。如果值是空，就找父函数？或者维护一个继承树？
    或者为了简化操作就强制绑定特定的函数？
    
    如何实现 Supper::(Bash的函数名可以用::符号) 呢？函数可以拿到对象变量名。进去后
    可以查看调用树。相应的 Supper 函数甚至可以用 eval 动态生成。


